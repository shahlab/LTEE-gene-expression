---
title: "Prepare data for GEO"
output: 
  html_document:
    df_print: paged
author: "John Favate"
date: "`r Sys.time()`"
---

<style type="text/css">
.main-container {
  max-width: 1100px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r}
# Prevent printing of warnings and such in the HTML
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.align = "center", eval = FALSE)
```

Instead of the actual raw files, GEO wants a "raw demultiplexed" file. This doesn't exist in our case, because the demultiplexed files are inherently the result of processing, namely adapter removal, demultiplexing, deduplication, then end trimming. The ends need to be trimmed for proper alignment, but that can't be done until after deduplication. We need to find all the read IDs in the demultiplexed, but not deduplicated files and retrieve them from the original file they came from. 

BBtools has a script for this. I use it here, after first matching the demultiplexed files to an original file. 
```{bash}
for FILE in ../../seqdata/3-demultiplexed/*.gz; do
  # don't do the unmatched files
  if [[ $FILE == *"unmatched"* ]]; then
    continue
  fi
  
  # get the file names
  FNAME=`echo $FILE | cut -d '/' -f 5 | cut -d '.' -f 1`
  
  # get the replicate 
  REP=`echo $FNAME | cut -d '-' -f 1`
  
  # get the seqtype
  SEQ=`echo $FNAME | cut -d '-' -f 2`
  
  # get am or ap
  if [[ $FNAME == *"AraM"* || $FNAME == *"AraR6"* ]]; then
    PM="am"
  else
    PM="ap"
  fi
  
  # the original fastq file
  OG=../../seqdata/1-original/$REP\-$SEQ\-$PM\.fq.gz
  
  # the place to write the OG reads to
  OUTFILE=../../seqdata/7-geo/og_demux_reads/$FNAME\.fq.gz
  
  # pull reads in a demux file from the OG file
  filterbyname.sh in=$OG out=$OUTFILE names=$FILE include=t
done
```

Done on amarel
```{bash}
for FILE in /scratch/jsf149/seqdata/input_seqdata/ltee/*; do
  # get the file names
  FNAME=`echo $FILE | cut -d '/' -f 7 | cut -d '.' -f 1`
  
  # get the replicate 
  REP=`echo $FNAME | cut -d '-' -f 1`
  
  # get the seqtype
  SEQ=`echo $FNAME | cut -d '-' -f 2`
  
  # get am or ap
  if [[ $FNAME == *"AraM"* || $FNAME == *"AraR6"* ]]; then
    PM="am"
  else
    PM="ap"
  fi
  
  # the original fastq file
  OG=/scratch/jsf149/seqdata/input_seqdata/ltee2/$REP\-$SEQ\-$PM\-fr.fq.gz
  
  # the place to write the OG reads to
  OUTFILE=/scratch/jsf149/seqdata/output_other/$FNAME\.fq.gz
  
  # pull reads in a demux file from the OG file
  echo in=$OG out=$OUTFILE names=$FILE include=t 
done > ~/demux_coms.txt
```

```{bash}
#!/bin/bash

#SBATCH --partition=p_shahlab_1   # Partition (job queue)
#SBATCH --requeue                 # Return job to the queue if preempted
#SBATCH --job-name=j_demux        # Assign an short name to your job
#SBATCH --cpus-per-task=1         # Cores per task (>1 if multithread tasks)
#SBATCH --mem-per-cpu=32000       # Real memory (RAM) required (MB)
#SBATCH --time=01:00:00           # Total run time limit (HH:MM:SS)
#SBATCH --error=slurm.%N.%j.err   # STDERR output file (optional)
#SBATCH --array=1-57%3

module load java/14.0.1

# make each line in the file a member of the array
LINE=$(sed -n "$SLURM_ARRAY_TASK_ID"p ~/demux_coms.txt)

~/bin/bbtools/bbmap/filterbyname.sh $LINE
```

rep2-ribo-AraM4.fq.gz